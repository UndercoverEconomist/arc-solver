import copy

def transform(grid):
    """
    Transforms a grid based on the proximity of '3's.

    When two '3's are adjacent (horizontally, vertically, or diagonally),
    a '4' is placed in the interstitial space between them.
    The original '3's remain. '3's with no adjacent '3's remain unchanged.
    Cells that are not '3' and not involved in a '3'-'3' interaction remain unchanged.

    Args:
        grid: A nested list representing the input grid.

    Returns:
        A nested list representing the transformed grid.
    """
    rows = len(grid)
    cols = len(grid[0])
    new_grid = copy.deepcopy(grid)

    # Define the 8 possible neighbor directions
    neighbors = [
        (-1, -1), (-1, 0), (-1, 1),
        (0, -1),           (0, 1),
        (1, -1), (1, 0), (1, 1)
    ]

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 3:
                for dr, dc in neighbors:
                    nr, nc = r + dr, c + dc

                    # Check if the neighbor is within grid bounds
                    if 0 <= nr < rows and 0 <= nc < cols:
                        # If the neighbor is also a '3'
                        if grid[nr][nc] == 3:
                            # Determine the interstitial cell
                            # This logic assumes that if two 3s are neighbors,
                            # the interstitial space is conceptually between them.
                            # For the purpose of placing a '4', we need a concrete cell.
                            # The story implies the '4' emerges "between them".
                            # A simple way to interpret this for grid placement is
                            # to consider the mid-point. However, since we are
                            # operating on a discrete grid and the '4' emerges
                            # from the interaction of two adjacent cells,
                            # the '4' should occupy a cell that is also adjacent
                            # to both original '3's.

                            # The story's examples show the '4' appearing in cells
                            # that are neighbors to *both* '3's.
                            # Let's find cells that are neighbors to both (r, c) and (nr, nc).
                            # This is a bit tricky for cells that are directly adjacent.
                            # The most straightforward interpretation from the examples is:
                            # If (r, c) is 3 and (nr, nc) is 3, and they are adjacent,
                            # then any cell (ir, ic) that is a neighbor to BOTH (r, c) and (nr, nc)
                            # will become a 4.

                            # However, the story states "emerged *between* them".
                            # This suggests the '4' should be in a location that is
                            # a direct neighbor to both '3's.
                            # For directly adjacent '3's, there isn't a single "between" cell.
                            # The examples clarify this:
                            # - If two '3's are separated by one cell, the middle cell becomes '4'.
                            # - If two '3's are directly adjacent, the '4' appears in a cell
                            #   that is adjacent to both.

                            # Let's refine based on the narrative: "spawned a '4' in the interstitial space"
                            # and "a '4' that bridges them".
                            # This implies the '4' is a new cell generated by the interaction.
                            # The most consistent interpretation with the examples is that
                            # if (r, c) and (nr, nc) are '3's, and they are neighbors,
                            # then any cell that is *also* a neighbor to both of them could become a '4'.
                            # The story implies the '4' is a result of the *proximity*.

                            # Let's consider the case where dr and dc are not zero.
                            # If dr is 0, they are horizontal neighbors. The interstitial space is conceptually between them.
                            # If dc is 0, they are vertical neighbors.
                            # If abs(dr) == 1 and abs(dc) == 1, they are diagonal neighbors.

                            # The key seems to be that if cell A and cell B are '3's and are neighbors,
                            # then any cell C that is adjacent to A AND adjacent to B should become a '4'.
                            # This is how the '4' bridges them.

                            # Let's iterate through all cells and check if they are adjacent to two '3's.
                            # This approach avoids placing multiple '4's for the same pair and handles
                            # overlapping interactions.

                            pass # This inner loop logic will be handled by the outer loop's check

    # Re-iterate to place the '4's based on identified interactions
    # We need to find cells that are neighbors to *two* '3's.
    for r in range(rows):
        for c in range(cols):
            # If the current cell is NOT a '3' itself, check if it's a '4' candidate
            if grid[r][c] != 3:
                neighboring_3s_count = 0
                for dr, dc in neighbors:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols:
                        if grid[nr][nc] == 3:
                            neighboring_3s_count += 1

                # If a cell has exactly two neighboring '3's, it becomes a '4'
                # This handles cases where a '4' is between two '3's.
                # The story implies this is the primary mechanism for '4' creation.
                # It also implies '3's themselves remain.

                # The narrative "It did not erase the original entities; rather, it emerged *between* them"
                # and "spawned a '4' in the interstitial space" suggests the '4' is a NEW cell.
                # The examples show that the original '3's remain.

                # Let's re-read the first example.
                # Isolated '3's in the center. They become neighbors. A '4' appears between them.
                # The '3's themselves are not shown to change in the output.
                # The second example shows '3's with neighbors. A '4' appears in the "bridging" cell.
                # The original '3's remain.

                # So, a cell becomes '4' IF it is a neighbor to at least two '3's.
                # However, the story is specific about "two such celestial bodies".
                # "When two such celestial bodies, the '3's, found themselves in close proximity – neighbors across a single cell or nestled within the same immediate expanse – a unique phenomenon occurred."
                # This suggests we are looking for pairs of '3's.

                # Let's use a different approach. Iterate through all '3's and their neighbors.
                # If a neighbor is also a '3', mark the interstitial space to become a '4'.

                # This requires careful handling of shared interstitial spaces.

                # A simpler interpretation of "interstitial space" and "bridging" might be:
                # If cell (r1, c1) is '3' and cell (r2, c2) is '3', and they are neighbors,
                # then the cell that is the "midpoint" or "bridge" becomes a '4'.
                # For directly adjacent cells (e.g., (0,0) and (0,1)), there isn't a single midpoint cell.
                # The examples are key here.

                # Example 1:
                # 000
                # 030
                # 000
                # ->
                # 000
                # 040  <-- This implies the cell itself became '4' IF it was a '3' and had a neighbor '3'.
                # 000
                # This contradicts "It did not erase the original entities".

                # Let's re-examine the ARC examples. The '3's *do* disappear in the first example and become '4's.
                # This is a crucial detail missed in the narrative interpretation.
                # The narrative is slightly misleading if the original '3's *can* become '4's.
                # "The '4' represented a burgeoning singularity, a point of concentrated potential born from the confluence of the two original powers. It did not erase the original entities; rather, it emerged *between* them, an intermingling of their fields."
                # This suggests the '4' is a *new* entity, not a transformation of the '3'.
                # However, the ARC examples are the ultimate source of truth.

                # In ARC example 1:
                # Input:
                # [[0,0,0],
                #  [0,3,0],
                #  [0,0,0]]
                # Output:
                # [[0,0,0],
                #  [0,4,0],
                #  [0,0,0]]
                # This implies if a cell is '3' AND has an adjacent '3', it becomes '4'.
                # This is a direct transformation of the '3' cell itself.

                # In ARC example 2:
                # Input:
                # [[3,0,0,3],
                #  [0,0,0,0],
                #  [3,0,0,3]]
                # Output:
                # [[3,0,0,3],
                #  [0,4,4,0],
                #  [3,0,0,3]]
                # Here, the '3's remain. The '4's appear *between* them.
                # The '4' at (1,1) is adjacent to (0,0) which is 3, and (2,0) which is 3.
                # The '4' at (1,2) is adjacent to (0,3) which is 3, and (2,3) which is 3.
                # This implies a cell becomes '4' if it is adjacent to two '3's.

                # These two interpretations are contradictory.
                # Let's prioritize the second example as it's more complex and the narrative
                # seems to align better with "emerged between them".
                # The first example might be a special case or a simplified representation.

                # If a cell (r, c) is NOT '3', and it has at least two neighbors that ARE '3',
                # then (r, c) becomes '4'.
                # If a cell (r, c) IS '3', and it has NO neighbors that ARE '3', it remains '3'.
                # If a cell (r, c) IS '3', and it HAS neighbors that ARE '3', it remains '3' (based on narrative "did not erase").

                # Let's stick to the interpretation that '4's appear in cells that are neighbors to two or more '3's.
                # And '3's themselves remain unless they are part of a '3'-'3' interaction that *transforms* them.
                # The narrative is key: "It did not erase the original entities". This implies the '3's should persist.

                # Let's re-evaluate the first example again. It's a very simple case.
                # If the input grid has only one non-zero element, and it's a '3', and there are no other '3's,
                # it remains '3'.
                # If there are two '3's that are adjacent, and they are the *only* non-zero elements,
                # then the '3's might indeed become '4's.

                # Let's try to unify:
                # A cell `(r, c)` becomes `4` if it is adjacent to at least two `3`s.
                # A cell `(r, c)` remains `3` if it is `3` AND it is NOT adjacent to any other `3`.
                # If a cell is `3` and IS adjacent to another `3`, what happens?
                # If the '3' itself becomes '4', that's the first example.
                # If the '3' remains and a '4' appears elsewhere, that's the second example.

                # The most consistent rule from the narrative and second example:
                # A cell `(r, c)` becomes `4` if it is adjacent to two or more `3`s.
                # Original `3`s remain `3`s if they are not transformed.
                # The transformation seems to be that the cell *between* the two `3`s becomes a `4`.

                # Let's try this:
                # Iterate through all cells.
                # If a cell `(r, c)` is `3`:
                #   Check its neighbors.
                #   For each neighbor `(nr, nc)` that is also `3`:
                #     The cell `(r, c)` itself becomes `4`. This is the interpretation of example 1.
                #     This contradicts the "did not erase" part if it means the '3' disappears.

                # Let's assume the narrative is more about the *concept* and the examples are literal.
                # Example 1: If a single '3' has a '3' neighbor, it becomes a '4'.
                # Example 2: If a '3' has a '3' neighbor, it *remains* a '3', and a '4' appears in the *neighboring cell* that is between them.

                # This implies a distinction between isolated pairs and larger structures.
                # The phrasing "found themselves in close proximity – neighbors across a single cell or nestled within the same immediate expanse"
                # seems to cover both direct adjacency and adjacency with one cell in between.

                # Let's go with the most common pattern from ARC examples:
                # A cell `(r, c)` becomes `4` if it is adjacent to two or more `3`s.
                # Original `3`s remain `3`s.
                # This rule fits example 2 perfectly.
                # How does it fit example 1?
                # Input: [[0,0,0],[0,3,0],[0,0,0]]
                # Here, the '3' at (1,1) has no '3' neighbors. So it should remain '3'.
                # The output is [[0,0,0],[0,4,0],[0,0,0]]. This implies the '3' *itself* changed.

                # This is a paradox. Let's trust the more complex example (example 2) and the narrative's core idea of "emergence between".

                # Revised strategy:
                # 1. Identify all cells that are '3'.
                # 2. For each '3' at `(r, c)`, check its neighbors.
                # 3. If a neighbor `(nr, nc)` is also a '3':
                #    This pair of `3`s `(r, c)` and `(nr, nc)` have interacted.
                #    The "interstitial space" needs to be identified.
                #    If `(r, c)` and `(nr, nc)` are directly adjacent (e.g., `(0,0)` and `(0,1)`),
                #    there isn't a single interstitial cell. This is where the narrative and examples diverge.

                # Let's consider the cell `(r, c)`.
                # If `grid[r][c]` is `3`:
                #   It might remain `3`.
                #   Or it might become `4` (as in example 1).

                # Let's try to implement the rule:
                # A cell `(r, c)` becomes `4` if it is adjacent to exactly two `3`s.
                # This captures the idea of a '4' bridging two '3's.
                # This would result in `4`s in the cells that are neighbors to two `3`s.

                # Consider a '3' at `(r, c)`.
                # If it has a neighbor '3' at `(nr, nc)`:
                #   The cell `(r, c)` itself is involved.
                #   The cell `(nr, nc)` itself is involved.
                #   The space *between* them is involved.

                # Let's reconsider example 1:
                # [[0,0,0],
                #  [0,3,0],
                #  [0,0,0]] -> [[0,0,0],
                #               [0,4,0],
                #               [0,0,0]]
                # This suggests that if a '3' has *any* '3' neighbor, it becomes a '4'.
                # This contradicts the "did not erase the original entities" statement if it implies the '3' should persist.

                # Let's go with the most explicit interpretation of the second example and the narrative:
                # A cell `(r, c)` becomes `4` if it is adjacent to two or more `3`s.
                # The original `3`s remain `3`s.
                # This fits example 2.
                # For example 1, if the input is `[[0,0,0],[0,3,0],[0,0,0]]`,
                # the '3' at `(1,1)` has zero '3' neighbors. So according to this rule, it should remain '3'.
                # The output `[[0,0,0],[0,4,0],[0,0,0]]` still poses a problem.

                # Let's assume the first example is a special case for a single isolated '3' that gains a neighbor.
                # The core rule for larger grids:
                # If a cell `(r, c)` is NOT `3`, but is adjacent to two or more `3`s, it becomes `4`.
                # If a cell `(r, c)` IS `3`, it remains `3`.

                # Let's implement this rule for the general case (like example 2).
                # The first example is likely a simplification or a base case.

                pass # The logic is better handled by iterating through potential '4' cells.

    # Create a copy to modify, preserving the original grid for checks
    output_grid = [row[:] for row in grid]

    for r in range(rows):
        for c in range(cols):
            # If the current cell is NOT a '3', check if it should become a '4'
            if grid[r][c] != 3:
                neighboring_3s_count = 0
                for dr, dc in neighbors:
                    nr, nc = r + dr, c + dc
                    # Check bounds and if neighbor is a '3'
                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 3:
                        neighboring_3s_count += 1

                # If a cell is adjacent to two or more '3's, it becomes a '4'
                # This rule fits example 2 and the "emerged between them" idea.
                if neighboring_3s_count >= 2:
                    output_grid[r][c] = 4
            # If the current cell IS a '3', it remains a '3' according to "It did not erase the original entities".
            # This is consistent with example 2.
            # If example 1 is the ONLY case where a '3' becomes a '4', then we need a special condition.
            # However, the general rule applied to example 1 would keep the '3' as '3'.

    # Let's re-examine example 1 and the narrative.
    # "When two such celestial bodies, the '3's, found themselves in close proximity... a unique phenomenon occurred."
    # "The '4' represented a burgeoning singularity... It did not erase the original entities; rather, it emerged *between* them"
    # This implies the '4' is a NEW entity.

    # If the goal is to reproduce the ARC examples, and example 1 shows a '3' becoming a '4',
    # then the rule must be that a '3' becomes a '4' if it has at least one '3' neighbor.
    # And for example 2, the '3's *also* have '3' neighbors, but they remain '3' and a '4' appears *between* them.
    # This suggests a complex interaction.

    # Let's try to model the rule for example 1:
    # A cell `(r, c)` becomes `4` if it is `3` AND has at least one `3` neighbor.
    # This transforms the '3' itself.

    # Now, let's apply this to example 2:
    # [[3,0,0,3],
    #  [0,0,0,0],
    #  [3,0,0,3]]
    # The '3' at (0,0) has neighbors (0,1)=0, (1,0)=0, (1,1)=0. No '3' neighbors. So it remains '3'.
    # The '3' at (0,3) has neighbors (0,2)=0, (1,2)=0, (1,3)=0. No '3' neighbors. So it remains '3'.
    # The '3' at (2,0) has neighbors (1,0)=0, (1,1)=0, (2,1)=0. No '3' neighbors. So it remains '3'.
    # The '3' at (2,3) has neighbors (1,3)=0, (1,2)=0, (2,2)=0. No '3' neighbors. So it remains '3'.
    # So with this rule, the '3's themselves would remain '3's.
    # Then, we need to place the '4's.
    # The '4' at (1,1) is adjacent to (0,0)=3 and (2,0)=3. So it becomes '4'.
    # The '4' at (1,2) is adjacent to (0,3)=3 and (2,3)=3. So it becomes '4'.

    # This logic seems to fit both examples IF we apply two distinct rules:
    # 1. If a cell is '3' AND has a '3' neighbor, it becomes '4'. (Covers example 1)
    # 2. If a cell is NOT '3' AND is adjacent to two or more '3's, it becomes '4'. (Covers example 2's '4' placement)

    # Combining these:
    # A cell `(r, c)` becomes `4` if:
    #   (a) `grid[r][c] == 3` AND it has at least one `3` neighbor.
    #   OR
    #   (b) `grid[r][c] != 3` AND it has at least two `3` neighbors.

    # Let's refine this. The "did not erase" strongly suggests the original '3's should remain if they don't transform.
    # The first example is the anomaly if the '3' disappears.
    # What if the '4' is *added* to the grid where it's "between"?
    # If we consider the total count of '3's.

    # Let's try to implement the logic that seems most consistent with "emerged between" and example 2:
    # - Original '3's persist.
    # - A cell becomes '4' if it's a neighbor to two or more '3's.

    # This implies the output grid should be based on the input grid, and then '4's are placed.
    final_grid = [row[:] for row in grid] # Start with a copy of the input

    for r in range(rows):
        for c in range(cols):
            # If the current cell is not a '3', check if it should become a '4'.
            if grid[r][c] != 3:
                neighboring_3s_count = 0
                for dr, dc in neighbors:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 3:
                        neighboring_3s_count += 1

                # If a cell is adjacent to two or more '3's, it becomes a '4'.
                # This is the most direct interpretation of "bridging" and "interstitial space".
                if neighboring_3s_count >= 2:
                    final_grid[r][c] = 4
            # If the cell is '3', it remains '3' based on "did not erase the original entities" and example 2.
            # This rule does NOT explain example 1's output where a '3' becomes a '4'.

    # Let's reconsider example 1. The output shows a '4' where there was a '3'.
    # This implies that a '3' *can* transform into a '4' under certain conditions.
    # The condition is "neighbors".
    # If a '3' has a '3' neighbor, it becomes a '4'.
    # What about example 2? The '3's remain '3's.
    # This suggests that the '3's in example 2 are NOT directly adjacent to other '3's.
    # Checking example 2:
    # (0,0) has no '3' neighbors.
    # (0,3) has no '3' neighbors.
    # (2,0) has no '3' neighbors.
    # (2,3) has no '3' neighbors.
    # So, the rule for example 1 holds: if a '3' has *no* '3' neighbors, it remains '3'.
    # If a '3' *does* have a '3' neighbor, it becomes a '4'. This is STILL contradictory with example 2.

    # The most plausible interpretation that reconciles the narrative and examples:
    # 1. Original '3's are preserved UNLESS they are involved in a '3'-'3' interaction that CREATES a '4'.
    # 2. A '4' is created in a cell if that cell is adjacent to two or more '3's. This is the primary mechanism for '4' creation.
    # 3. Example 1 is a special case where the *only* non-zero element is a '3'. If this '3' were to have a neighbor (e.g., if it were part of a larger grid), it would behave differently.
    #    The simplest explanation for Example 1 is that the '3' itself becomes a '4' when it's a solitary '3' in a context that implies potential interaction.
    #    However, the narrative says "emerged between them".

    # Let's assume the rule is:
    # A cell `(r, c)` becomes `4` if it is adjacent to two or more `3`s.
    # AND
    # If a cell `(r, c)` is `3`, it remains `3` UNLESS it is involved in a way that implies its transformation.

    # The most robust interpretation that fits example 2 and the narrative:
    # A cell `(r, c)` becomes `4` if it is adjacent to two or more `3`s.
    # All other cells, including the original `3`s, retain their original values.

    # Let's implement this.
    # This still doesn't explain example 1 where the '3' *becomes* a '4'.
    # The only way to explain example 1 is if the '3' itself transforms.
    # "When two such celestial bodies... found themselves in close proximity... a unique phenomenon occurred."
    # In example 1, there is effectively only ONE '3'. It doesn't have a neighbor.
    # However, if we consider a conceptual neighbor (e.g., if the grid were larger and this '3' was near another),
    # then the '3' would transform.

    # Let's try a rule that accounts for both:
    # A cell `(r, c)` becomes `4` IF:
    #   (a) `grid[r][c] == 3` AND it has at least one neighbor `(nr, nc)` where `grid[nr][nc] == 3`. (This covers example 1 IF the '3' itself transforms)
    #   OR
    #   (b) `grid[r][c] != 3` AND it has at least two neighbors `(nr1, nc1)` and `(nr2, nc2)` where `grid[nr1][nc1] == 3` AND `grid[nr2][nc2] == 3`. (This covers example 2's '4' placement)

    # This combined rule seems to be the most comprehensive.
    # Let's implement this.

    final_grid = [[0 for _ in range(cols)] for _ in range(rows)]

    for r in range(rows):
        for c in range(cols):
            is_3 = (grid[r][c] == 3)
            neighboring_3s_count = 0
            has_3_neighbor = False

            for dr, dc in neighbors:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols:
                    if grid[nr][nc] == 3:
                        neighboring_3s_count += 1
                        has_3_neighbor = True

            # Rule (a): If the cell itself is '3' and has a '3' neighbor, it becomes '4'.
            if is_3 and has_3_neighbor:
                final_grid[r][c] = 4
            # Rule (b): If the cell is not '3' and has two or more '3' neighbors, it becomes '4'.
            elif not is_3 and neighboring_3s_count >= 2:
                final_grid[r][c] = 4
            # Otherwise, retain the original value.
            else:
                final_grid[r][c] = grid[r][c]

    return final_grid